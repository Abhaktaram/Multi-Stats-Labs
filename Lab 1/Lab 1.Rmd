---
title: "Lab 1"
author: "Ananya Bhaktaram"
date: "`r Sys.Date()`"
output: html_document
---

# Part A
Multivariate Gaussian (aka "normal" - it is not) distribution: the univariate Gaussian distribution can be extended to handle a vector of two ("bivariate") or more ("multivariate") random variables of length n.  In this case, the mean vector also has length n and the variance/covariance matrix is n x n  (n rows and n columns).  The n diagonal elements of the square covariance matrix contain the variances for the n individual random variable, and the off-diagonal elements are the covariances for each of the "n choose 2" (n(n-1)/2) possible pairs of random variables.

For instance, the multivariate Gaussian distribution for $\begin{pmatrix} Y_{i1} \\ Y_{i2} \\ Y_{i3} \end{pmatrix}$ is given by:

$$\begin{pmatrix} Y_{i1} \\ Y_{i2} \\ Y_{i3} \end{pmatrix} \sim MVN\left(\begin{pmatrix} \mu_1 \\ \mu_2 \\ \mu_3 \end{pmatrix}, \begin{pmatrix} \sigma_1^2 & \sigma_1\sigma_2\rho_{12} & \sigma_1\sigma_3\rho_{13} \\ \sigma_1\sigma_2\rho_{12} & \sigma_2^2 & \sigma_2\sigma_3\rho_{23} \\ \sigma_1\sigma_3\rho_{13} & \sigma_2\sigma_3\rho_{23} & \sigma_3^2 \end{pmatrix}\right)$$


### Question 1: 

What do the values μ_2 and 〖σ_2〗^2 represent? Hand draw the distribution of Y_i2 labeling the mean and standard deviation in your figure. (10 pts)

μ_2 is the population variable mean at Y_i2.

〖σ_2〗^2 is the populations variance at time Y_i2.

```{r}
## Visualization of Y_i2 distribution
library(ggplot2)

library(ggplot2)

# Set parameters
mu2 <- 5
sigma2 <- 2

# Create data frame
x <- seq(mu2 - 4*sigma2, mu2 + 4*sigma2, length.out = 1000)
df <- data.frame(x = x, y = dnorm(x, mu2, sigma2))

# Create plot
ggplot(df, aes(x = x, y = y)) +
  geom_line(color = "blue", size = 1) +
  geom_vline(xintercept = mu2, color = "red", linetype = "dashed", size = 1) +
  geom_vline(xintercept = c(mu2 - sigma2, mu2 + sigma2), 
             color = "green", linetype = "dotted") +
  annotate("text", x = mu2, y = 0.01, label = expression(mu[2]), 
           color = "red", size = 5) +
  annotate("text", x = mu2 - sigma2, y = 0.005, 
           label = expression(mu[2] - sigma[2]), color = "green", size = 3) +
  annotate("text", x = mu2 + sigma2, y = 0.005, 
           label = expression(mu[2] + sigma[2]), color = "green", size = 3) +
  labs(title = expression("Distribution of Y"[i2]),
       x = expression("Y"[i2]),
       y = "f(y)") +
  theme_minimal()
```

### Question 2:

What does the value σ_1 σ_3 ρ_13 represent? (10 pts)

The covariance between the first population mean and the third population mean, which is equivalent to SQRT Var (Yi1) SQRT  Var (Yi3) * Corr (Yi1Yi3).

### Question 3: 

Interpret the values ρ_12, ρ_13 and ρ_23? (10 pts)

ρ_12 represents the correlation between time point 1 and 2.

ρ_13 represents the correlation between time point 1 and 3.

ρ_23 represents the correlation between time point 2 and 3.

# Part B

Consider the multivariate Gaussian model for our application where, for each individual, we have 5 repeated measurements of the SF-36 mental health score at hospital discharge and then monthly for 4 months.  The parameters associated with this multivariate (n = 5) Gaussian distribution comprise: 5 means, 5 variances and (5×(5-1))/2=10 pairwise correlations.  

Let Y_(ij )be the SF-36 mental health score for subject i = 1, …, 100, at visit j = 1, 2, 3, 4, 5 corresponding to hospital discharge (j = 1), and subsequent monthly assessments (j = 2, 3, 4, 5). 

Assume the data for subject i are generated at random from a multivariate Gaussian distribution with: means 35, 38, 43, 49, 48 for j = 1, 2, 3, 4, 5;  equal variances over time of 100; and correlation ρjk for times j and k of ρ12 = 0.85, ρ13 = 0.80, ρ14 = 0.72, ρ15 = 0.69, ρ23 = 0.85, ρ24 = 0.80, ρ25 = 0.72, ρ34 = 0.85, ρ35 = 0.80, ρ45 = 0.85. 

### Question 4
In the space below, practice your understanding of the notation by writing out the multivariate (n=5) Gaussian distribution. (10 pts)

$$\begin{pmatrix} Y_{i1} \\ Y_{i2} \\ Y_{i3} \\ Y_{i4} \\ Y_{i5} \end{pmatrix}
\sim MVN\left(\begin{pmatrix} \ 35 \\ 38 \\ 43 \\ 39 \\ 48\end{pmatrix}, 
\begin{pmatrix}
1.00 & 0.85 & 0.80 & 0.72 & 0.69 \\
0.85 & 1.00 & 0.85 & 0.80 & 0.72 \\
0.80 & 0.85 & 1.00 & 0.85 & 0.80 \\
0.72 & 0.80 & 0.85 & 1.00 & 0.85 \\
0.69 & 0.72 & 0.80 & 0.85 & 1.00
\end{pmatrix}\right)$$
 
### Question 5:
Describe in a sentence or two the pattern you observe in the correlations for pairs of observations.  Use the "autocorrelation matrix" (ACM) above to obtain the "autocorrelation function "(ACF): \rho(u)=corr(Y_{ij\ },Y_{ij+u}),\ u=1,...,4. Briefly describe the approach/method you used to obtain the ACF from the ACM. Given your lay understanding of the SF-36 measure, how is nature likely to work to produce the ACF pattern you observe. (10 pts)

The pattern shown in the correlations generally decreases as the time gap increases, which is typical for longitudinal data as measurements that are closer to one another in time are more likely to be highly correlated.

The autocorrelation function measures the correlation between measurements separated by u time units: 
\rho(1) = the correlation between consecutive time points (lag 1)
\rho(2) = the correlation between time points that are 2 units apart (lag 2)
\rho(3) = the correlation between time points that are 3 units apart (lag 3)
\rho(4) = the correlation between time points that are 4 units apart (lag 4)

```{r}
## Calculating the autocorrelation function

# Read in correlation matrix
R <- matrix(c(
  1.00, 0.85, 0.80, 0.72, 0.69,
  0.85, 1.00, 0.85, 0.80, 0.72,
  0.80, 0.85, 1.00, 0.85, 0.80,
  0.72, 0.80, 0.85, 1.00, 0.85,
  0.69, 0.72, 0.80, 0.85, 1.00
), nrow = 5, byrow = TRUE)

# Simple function to extract autocorrelations
get_autocorr <- function(corr_matrix) {
  n <- nrow(corr_matrix)
  autocorr <- numeric(n-1)
  
  for(u in 1:(n-1)) {
    # Extract diagonal u positions above main diagonal
    autocorr[u] <- corr_matrix[1, 1+u]  # Since structure is stationary
  }
  
  return(autocorr)
}

# Calculate
rho <- get_autocorr(R)
names(rho) <- paste0("lag_", 1:4)
print(rho)
```
Because the correlation between any two time points only depends on their distance (the lag) not their absolute positions all correlations at the same lag are equal. Given that the the lags are symmetric the autocorrelation function is able to summarize the pattern between time points that are stored in the matrix. In this case, because the effects are stationary the correlations given by the ACF and the ACM are the same. 

For example, an interpretation of both the ACM and ACF would be the same. In this case, a Patient's mental health (SF-36 score) at discharge (Time 1) has a 0.85 correlation with their 1-month follow-up (Time 2). Similarly, because the distance between Time 2 and Time 3 is the same as that between Time 1 and Time 2 this tells us that a Patient's SF-36 score at their 1 month follow up (Time 2) has a 0.85 correlation with their SF-36 score at their 2-month follow-up (Time 3). Overall, we see that the correlation decreases as the lag (time between follow-ups) increases. For example, the patient's SF-26 score at discharge (Time 1) only has a 0.69 correlation with their score at 4-month follow-up (TIme 5).

# Part C: Simulating Multivariate Gaussian Data

### Question 6: 

Simulate 100 random draws from the multivariate Gaussian distribution for the SF-36 data whose true mean and covariance matrix is specified above (and in the code).  Report the first 5 draws in the space below. (10 pts)
```{r}
install.packages("mvtnorm")
library(mvtnorm)
set.seed(02022022) # Important for reproducibility
mm <- c(35, 38, 43, 49, 48)
C <- matrix(c(1.00,0.85,0.80,0.72,0.69,
              0.85,1.00,0.85,0.80,0.72,
              0.80,0.85,1.00,0.85,0.80,
              0.72,0.80,0.85,1.00,0.85,
              0.69,0.72,0.80,0.85,1.00),
            nrow = 5) 
sigma <- C * 100
y <- rmvnorm(n=100, mean=mm, sigma=sigma)
id <- seq(1,100)
dat <- as.data.frame(cbind(y,id))
names(dat) <- c("y0","y1","y2","y3","y4","id")

head(C, 5)

```

### Question 7: 
Display your simulated data using a spaghetti plot and a pairs plot. Calculate the mean and covariance matrix for your sample of n=100 simulated vectors. Use these plots and estimates to describe the patterns of potential scientific interest in the SF-36 data. (10 pts)
```{r}
# Load Libraries
library(tidyverse)
library(nlme)
library(mvtnorm)
install.packages("joineR")
library(joineR)
install.packages("GGally")
library (GGally)
```

```{r}
# Use your simulated SF-36 data (stored as dat)
# Convert to long format for analysis
df_long <- dat %>%
  pivot_longer(cols = y0:y4, 
               names_to = "time_point", 
               values_to = "SF36_score") %>%
  mutate(
    time_numeric = as.numeric(str_extract(time_point, "\\d+")),
    time_label = case_when(
      time_numeric == 0 ~ "Discharge",
      time_numeric == 1 ~ "Month 1", 
      time_numeric == 2 ~ "Month 2",
      time_numeric == 3 ~ "Month 3",
      time_numeric == 4 ~ "Month 4"
    )
  )

# Count unique subjects
n <- length(unique(df_long$id))
print(paste0("Number of subjects: ", n))

# Generate summaries for plotting
time.summaries <- df_long %>%
	group_by(time_numeric, time_label) %>%
	summarise(avgSF36 = mean(SF36_score),
	          sdSF36 = sd(SF36_score),
	          medSF36 = median(SF36_score),
	          q75SF36 = quantile(SF36_score, 0.75),
	          q25SF36 = quantile(SF36_score, 0.25),
	          .groups = 'drop')

print(time.summaries)
```

Visualize the sample means with a 95% confidence interval
```{r}
time.summaries %>%
	ggplot() +
	geom_point(aes(x = time_numeric, y = avgSF36), color = "red", size = 2) +
	geom_line(aes(x = time_numeric, y = avgSF36), color = "red", size = 1) +
  geom_pointrange(aes(x = time_numeric, y = avgSF36,
                      ymin = avgSF36 - 2*sdSF36/sqrt(n), 
                      ymax = avgSF36 + 2*sdSF36/sqrt(n))) +
	scale_x_continuous(breaks = 0:4, 
	                   labels = c("Discharge", "Month 1", "Month 2", "Month 3", "Month 4")) +
  scale_y_continuous(breaks = seq(30, 55, 5)) +
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10)) +
	xlab("Time Point") +
	ylab("SF-36 Mental Health Score") +
	ggtitle("Average SF-36 Mental Health Scores Over Time (95% CI)")
```
Plot median and IQR
```{r}
time.summaries %>%
  ggplot() +
  geom_point(aes(x = time_numeric, y = medSF36), color = "blue", size = 2) +
  geom_line(aes(x = time_numeric, y = medSF36), color = "blue", size = 1) +
  geom_pointrange(aes(x = time_numeric, y = medSF36, 
                      ymin = q25SF36, ymax = q75SF36)) +
  scale_x_continuous(breaks = 0:4, 
                     labels = c("Discharge", "Month 1", "Month 2", "Month 3", "Month 4")) +
  scale_y_continuous(breaks = seq(30, 55, 5)) +
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10)) +
  xlab("Time Point") +
  ylab("SF-36 Mental Health Score") +
  ggtitle("Median SF-36 Mental Health Scores Over Time (IQR)")
```
Look at distributions within each timepoint using boxplots
```{r}
df_long %>%
  ggplot() +
  geom_boxplot(aes(group = time_numeric, x = time_numeric, y = SF36_score)) +
  theme_bw() +
  scale_x_continuous(breaks = 0:4, 
                     labels = c("Discharge", "Month 1", "Month 2", "Month 3", "Month 4")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  xlab("Time Point") +
  ylab("SF-36 Mental Health Score") +
  geom_line(aes(group = id, x = time_numeric, y = SF36_score), 
            alpha = 0.3, colour = "grey") + 
  ggtitle("Individual SF-36 Mental Health Score Trajectories")
```
Overlay mean trajectory to create final spaghetti plot
```{r}
ggplot(df_long) +
  geom_boxplot(aes(group = time_numeric, x = time_numeric, y = SF36_score)) +
	geom_line(aes(group = id, x = time_numeric, y = SF36_score), 
	          alpha = 0.3, colour = "grey") +
	theme_bw() +
	scale_x_continuous(breaks = 0:4, 
	                   labels = c("Discharge", "Month 1", "Month 2", "Month 3", "Month 4")) +
	theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
	xlab("Time Point") +
	ylab("SF-36 Mental Health Score") +
  geom_point(data = time.summaries, aes(x = time_numeric, y = avgSF36), 
             color = "red", size = 2) +
  geom_line(data = time.summaries, aes(x = time_numeric, y = avgSF36), #This is assing the mean trajctory line
            color = "red", size = 1.2) +
  geom_pointrange(data = time.summaries, 
                  aes(x = time_numeric, y = avgSF36,
                      ymin = avgSF36 - 2*sdSF36/sqrt(n), 
                      ymax = avgSF36 + 2*sdSF36/sqrt(n)),
                  color = "red") +
  ggtitle("SF-36 Mental Health Score Trajectories with Population Mean")
```
### Question 8: 
8. Calculate the autocorrelation matrix and autcorrelation function for your simulated data. Describe what else these estimates contribute to our understanding of the SF-36 data. (10 pts)

```{r}
# Calculate covariance matrix
cov_mat = df.wide %>% 
  select(-id) %>%
  cov() 

cov_mat[upper.tri(cov_mat)] = NA
cov_mat %>%
  as.data.frame()

```

Calculate autocorrelation of the residuals
```{r}
# The autocor command requires you to give: the residual, time variable, id variable
fit = gls(SF36_score~as.factor(time_numeric),df_long)
acf1 = ACF(fit,form= ~1|id)
acf1

# generate the lower bound
acf1 = acf1 %>%
	mutate(upper = 2 * 1 / sqrt(51 * (5-lag)))

# Make the plot
acf1 %>% 
  ggplot() + 
  geom_line(aes(x=lag, y=ACF))  +
  geom_line(aes(x=lag, y=upper), linetype=2) + 
  xlab("Lag (months)") +
  ylim(0,1.02) +
  theme_bw() +
  ggtitle("Autocorrelation Function for Simulated SF-36 Scores")
```

Fit the saturated model: single factor anova, month is the factor

```{r}
# First convert to long format for model fitting
df_long <- dat %>%
  pivot_longer (cols = y0:y4, 
                names_to = "time_point",
                values_to = "SF36_score") %>%
  mutate(
    time_numeric = as.numeric(str_extract(time_point, "\\d+"))
  )

# Fit the model with time as a factor
mod1 = lm(data = df_long, SF36_score ~ factor(time_numeric))
df_long$resid1 = residuals(mod1)

# Reshape residuals back to wide format
df.wide = df_long %>% 
  select(id, time_point, resid1) %>%
  mutate(time_point = paste0(time_point, " Residuals")) %>%
  pivot_wider(names_from = time_point, values_from = resid1)

# Calculate covariance matrix
cov_mat = df.wide %>% 
  select(-id) %>%
  cov() 

cov_mat[upper.tri(cov_mat)] = NA
cov_mat %>%
  as.data.frame()
```
Create Scatterplot matrix
```{r}
panel.corr <- function(x, y){
    usr <- par("usr"); on.exit(par(usr))
    par(usr = c(0, 1, 0, 1))
    r <- round(cor(x, y), digits=3)
    txt <- paste0("Corr: ", r)
    text(0.5, 0.5, txt, cex = 1)
}

df.wide %>% 
  select(-id) %>%
  pairs(upper.panel = panel.corr)
```
Calculate autocorrelation of the residuals
```{r}
# The autocor command requires you to give: the residual, time variable, id variable
fit = gls(SF36_score~as.factor(time_numeric),df_long)
acf1 = ACF(fit,form= ~1|id)
acf1

# generate the lower bound
acf1 = acf1 %>%
	mutate(upper = 2 * 1 / sqrt(51 * (5-lag)))

# Make the plot
acf1 %>% 
  ggplot() + 
  geom_line(aes(x=lag, y=ACF))  +
  geom_line(aes(x=lag, y=upper), linetype=2) + 
  xlab("Lag (months)") +
  ylim(0,1.02) +
  theme_bw() +
  ggtitle("Autocorrelation Function for Simulated SF-36 Scores")
```

```{r}
# Generate pairs plot
panel.corr <- function(x, y) {
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(0,1,0,1))
  r <- round(cor(c,y), digits=3)
  txt <- paste0("Corr: ", r)
  text(0.5, 0.5, txr, cex =1)
}

dat %>%
  select(y0, y1, y2, y2, y4) %>%
  pairs(upper.panel = panel.corr, 
        main = "Pairs Plot: Simulated Sf-36 Mental Health Scores")
```

